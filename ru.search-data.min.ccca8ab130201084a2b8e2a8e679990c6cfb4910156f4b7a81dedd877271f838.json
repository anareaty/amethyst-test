[{"id":0,"href":"/feed/","title":"Лента","section":"Paperless Forest","content":"\r\nfeed\r\n"},{"id":1,"href":"/pocketbook-collection-calibre-plugin/","title":"Pocketbook Collections — мой новый плагин для Calibre","section":"Paperless Forest","content":"Преамбула #  У меня есть большая коллекция электронных книг, и для их организации на компьютере я использую потрясающую программу [[../Calibre|Calibre]]. Это очень мощная программа, позволяющая конвертировать книги, изменять их метаданные, организовавыть по категориям, переименовывать файлы и отправлять их на подключённое устройство для чтения, а также многое, многое другое.\nСами книги я предпочитаю читать на моей читалке [[../Pocketbook|Pocketbook]] 627. В этой читалке очень удобная библиотека, позволяющая фильтровать книги по жанрам, авторам и сериям, но кроме того там есть возможность отмечать книги как прочитанные, добавлять их в избранное или в пользовательские коллекции.\nК сожалению, управлять коллекциями с самого устройства не очень удобно из-за медленной работы e-ink-экрана, особенно если нужно рассортировать по коллекциям большое количество книг сразу. Поэтому мне давно хотелось иметь возможность управлять коллекциями на читалке с компьютера. Так что несколько лет назад я даже написала [[./pocketbook-collection-manager|приложение]] для этого.\nВ принципе это приложение работает, но я им недовольна: оно сырое, медленное и не слишком удобное, потому что, когда я его писала, то только пыталась разобраться, как вообще устроен код, и не особенно представляла, что вообще делаю. К тому же, тогда я более-менее знала только Javascript, поэтому приложение написано на Electron, что, на мой взгляд, не лучший выбор для такой задачи. По мере использования я столкнулась и с ещё одной проблемой: приложение изменяло данные на устройстве, но не сохраняло их на компьютере, так что в случае перезаписывания книг на устройстве, все коллекции приходилось сортировать заново.\nВ последнее время я начала чувствовать себя более уверенно с программированием, поэтому у меня появилась мысль доработать приложение, чтобы сделать его более удобным. Однако потом я посмотрела на всю эту кучу кода и подумала: почему бы просто не написать плагин для Calibre? В таком случае мне не нужно будет писать графическую оболочку, все эти фильтры и кнопки, а достаточно просто добавить логику для синхронизации данных в Calibre с базой данных читалки.\nЧеллендж заключался в том, что плагины для Calibre пишутся на Python, с которым я прежде не работала и знаю только самые основы. Так что пришлось разбираться, гуглить и ковыряться в чужом коде, но в итоге, после пары недель мучений я его всё-таки написала!\nПринцип работы #  Плагин позволяет синхронизировать коллекции, а также статус прочтения и статус избранного между книгами в Calibre и книгами в читалке Pocketbook.\nДля этого в Calibre нужно будет создать три дополнительные колонки:\n колонку \u0026ldquo;#shelf\u0026rdquo; с типом \u0026ldquo;Текст, разделённый запятыми, работает как тэги\u0026rdquo;; колонку \u0026ldquo;#read\u0026rdquo; с типом \u0026ldquo;да / нет\u0026rdquo;; колонку \u0026ldquo;#favorite\u0026rdquo; с типом \u0026ldquo;да / нет\u0026rdquo;.  Можно указать другие названия колонок в настройках плагина.\nПосле подключения читалки к компьютеру по USB , в главном меню появится иконка плагина Pocketbook Collections. При клике на кнопку меню можно увидеть список команд для плагина.\nКоманды позволяют отправлять данные из Calibre в читалку или наоборот, выгружать из читалки в Calibre. Можно отправлять и выгружать сразу всё, либо коллекции и статусы по отдельности.\n [!info] Ссылки\nПлагин можно скачать здесь и установить вручную в настройках Calibre с помощью команды «Загрузить плагин из файла». Надеюсь, что скоро от накже появится в списке автоматической загрузки. А вот здесь написала пост о плагине на форуме Mobileread.\n Примечания #  Я пробовала также добавить двухстороннюю синхронизацию, основанную на времени последнего изменения, но результат мне не понравился. Во-первых, на моём Покетбуке почему-то иногда сбивается время, что приводит к ошибкам в таймштампах. Во-вторых, Calibre не сохраняет отдельные таймштампы для каждой колонки, а только хранит время изменения всей книги. Из-за этого было не всегда возможно точно определить, где именно — в Calibre или на читалке — произошли последние изменения коллекций и статусов, чтобы сохранить релевантные данные. Возможно я ещё попробую реализовать эту функцию позже, но пока что ручной выбор отправляемых и загружаемых данных выглядит надёжнее.\nЯ также думаю о том, не добавить ли синхронизацию позиции чтения, заметок и закладок, или что там есть ещё. Не то чтобы мне был очень нужен этот функционал, но теоретически он может быть полезен. Но это как-нибудь потом.\n [!important] Важно\nПлагин позволяет добавлять данные только для книг, которые уже есть на устройстве и проиндексированы. Pocketbook индексирует новые книги только после отключения читалки от компьютера. Это означает, что если вы добавили в читалку новые книги, нужно отсоединить её от компьютера, подождать, пока устройство обнаружит книги и добавит их в базу данных, затем снова подключить читалку к компьютеру, и тогда уже можно будет добавить коллекции для новых книг.\n Плагин протестирован только на моём устройстве Pocketbook 627, но он может работать и с другими читалками Pocketbook при условии, что они используют ту же самую структуру базы данных.\n"},{"id":2,"href":"/why-i-use-obsidian/","title":"Почему я использую Obsidian","section":"Paperless Forest","content":"Obsidian — это приложение для заметок, которым я пользуюсь уже пару лет, и со временем оно мне нравится всё больше и больше.\nНа самом деле я уже давно использую приложения для заметок. Когда я только купила свой первый смартфон, я сразу стала искать способ делать в нём записи на ходу, и сразу наткнулась на приложение Evernote. На первый взгляд, Evernote был именно тем, что мне нужно: можно писать заметки на разных устройствах и синхронизировать их друг с другом, есть способы добавлять информацию из интернета, можно категоризировать заметки и объединять их друг с другом\u0026hellip; На тот момент Evernote казался самым лучшим приложением для заметок, я позьзавалась им много лет и даже написала в нём свою дипломную работу.\nВот только, если честно, все эти годы Evernote меня ужасно бесил. У меня были с этим приложением какие-то токсичные отношения. Чуть ли не каждый месяц я принималась гуглить «альтернативы Evernote», и каждый раз, как появлялось какое-то новое приложение для заметок, я пыталась переехать в него, однако каждый раз возвращалась к бесячему слону, потому что другие приложения были ещё хуже.\nПотом появился Notion. Notion меня очаровал. Он был настолько мощным, там было столько возможностей! Я перенесла в него все свои заметки и потратила кучу времени на то, чтобы настроить несколько таблиц с формулами и всем таким. Однако очарование длилось недолго: Notion оказался очень удобен для хранения, структуризации и представления информации, но единственное, что в нём оказалось совершенно неудобно делать, так это писать.\nЕщё одно приложение, которым я пользовалась довольно долгое время — Workflowy. Это аутлайнер, и он был очень хорош для быстрых заметок и для планирования, какое-то время я вела в нём задачи и делала небольшие записи на ходу. Однако мне нужно было также писать длинные тексты, а для этого Workflowy, как и другие аутлайнеры, не слишком подходил.\nДля написания длинных текстов я также пробовала использовать Scrivener. Это приложение для писателей, и оно довольно крутое, но у него был один существенный недостаток: отсутствие версии для Android. Они много лет обещали её добавить, но, по-моему, воз и ныне там. Попытки же редактировать файлы из Скривенера в каком-нибудь альтернативном приложении выглядели довольно печально.\nЭто не полный список приложений, которые я использовала. На самом деле, я, кажется, перепробовала все доступные варианты, по крайней мере точно все бесплатные (и некоторые платные). Но ни одно не было идеальным. На самом деле меня это здорово фрустрировало долгие годы.\nТеперь, прежде чем я смогу рассказать, чем же так хорош Обсидиан и почему он изменил мою жизнь, я хочу пояснить, чем же мне так не нравились все остальные приложения. Конечно, ни одно приложение вообще не идеально но больше всего меня беспокоило несколько главных проблем:\n Отсутствие локального доступа.  Это то, что больше всего раздражало в Notion и Workflowy, а также в бесплатной версии Evernote. Заметки хранились где-то там в облаке, и я не могла получить к ним доступ без интернета. Конечно, сейчас интернет есть почти везде, но тут ключевое слово «почти». Если я в лесу, в метро, в самолёте, если я случайно пропустила оплату счёта за интернет или на линии случился разрыв кабеля, я не могу открыть свои собственные заметки. Иногда бывало так, что интернет как бы есть, но соединение плохое, и поэтому даже самая простая и короткая заметка типа списка покупок открывалась невыносимо медленно. Нет слов, как меня это раздражало. В платной версии Evernote можно было подключить оффлайновые блокноты, и несколько раз я покупала подписку, но, честно говоря, необходимость платить за то, чтобы просто хранить свои заметки на своём же устройстве — это бред какой-то.\nМедлительность приложений в целом.  По какой-то причине, даже если заметки были сохранены локально, в большинстве приложений они всё равно открывались слишком медленно либо подтормаживали во время ввода текста. Подозреваю, причиной тому постоянная синхронизация или же слишком сложная структура страницы, сложно сказать.\nУ меня вообще не очень высокие требования к заметкам: я редко использую какое-то сложное форматирование, в большинстве случаев мне нужен просто текст. Что может быть проще текста? Текст должен быстро прогружаться и не должен лагать при введении, только и всего. Но иногда заметка в Эверноуте прогружалась по две минуты, а в Notion оказалось совершенно невозможно писать из-за тормозящего ввода.\nПроблемы с синхронизацией.  Окей, но если заметки хранятся в облаке, то это цена, которую мы платим за идеальную бесшовную синхронизацию, верно? Вот только и это не работало так хорошо, как хотелось бы. Нередко в самых разных приложениях у меня терялись данные из-за глюков с синхронизацией. Часто, особенно при плохом интернете, вводимый текст вообще не сохранялся, и после синхронизации я получала старую версию. Или синхронизация переставала работать по непонятной причине.\nОтсутствие синхронизации.  Из-за вышеупомянутых проблем, я пыталась использовать также локальные приложения. Их преимуществом было то, что они работали быстрее и обычно не теряли данные. Однако это также означало, что заметки нельзя синхронизировать вообще никак. В первую очередь я говорю сейчас о приложениях на Андроиде, на компьютере по крайней мере можно было закинуть файлы в папку Яндекс-диска или другого облака, но с большинством заметок на Андроиде это было невозможно.\nНевозможность открыть заметки из другого приложения.  Мне иногда приходится работать на чужих комьютерах или в системах, где установить нужное приложение невозможно. И даже если у меня был доступ к файлам заметок, я не могла их открыть, потому что они хранились в специальном формате, который могло открыть только данное приложение. Или, например, если бы я забыла пароль от Evernote, то не смогла бы авторизироваться в приложении, а значит, потеряла бы доступ к своим заметкам, даже если они сохранены локально на устройстве.\nЯ пыталась использовать приложения, использующие открытые форматы, такие как rtf или txt, но в основном такие приложения были неудобны или не работали достаточно хорошо на Android.\nОграниченные возможности категоризации заметок.  Большинство приложений, которые я пробовала, поддерживало только тэги или только папки. В Evernote можно было использовать тэги и блокноты, но у блокнотов почему-то было ограничение на всего два уровня вложенности. Мне хотелось иметь более гибкую систему категоризации.\nБыли и другие мелкие проблемы или фишечки, которые мне не нравились в разных приложениях, но всё это было достаточно терпимо. По большей части у меня были простые требования: возможность писать заметки быстро, без тормозов и даже в отсутствие интернета, синхронизировать и без проблем открывать их на любых устройствах, а также иметь возможность их систематизировать и легко находить нужную заметку. Всё остальное — уже дополнительные свистелки и рюшечки. Но, к сожалению, даже эти простые требования большинство приложений выполняло недостаточно хорошо.\nИ вот наконец в моей жизни появился Obsidian.\nУ Обсидиана много достоинств, но самым важным для меня является то, что он хранит заметки локально, в открытом формате, причём не в какой-нибудь секретной закрытой папке, а в любом месте на устройстве. Это означает, что:\n заметки всегда доступны без интернета; заметки открываются очень быстро; файлы заметок можно открывать и редактировать не только в Обсидиане, но и в других приложениях, даже в обычном блокноте; текст заметок можно обрабатывать при помощи простых скриптов; заметки можно синхронизировать при помощи сторонних сервисов, таких как облака, Syncthing, Git и т. п. (и такую синхронизацию можно контролировать, например, включать и выключать по необходиости), а также легко делать бэкапы вручную.  При этом у Обсидиана есть особые преимущества перед другими приложениями для редактирования простых текстовых файлов:\n очень гибкие возможности категоризации заметок (можно использовать папки, тэги, ссылки, поиск по метаданным и т. п.); режим живого просмотра Markdown (который сочетает в себе простой ввод форматирования с эстетичным отображением текста); безграничная кастомизируемость при помощи плагинов, тем, скриптов и css-снипеттов (Обсидиан можно заставить выглядеть как угодно и добавлять к нему почти любые дополнительные функции).  Благодаря всем этим качествам Обсидиан стал для меня идеальным приложением для заметок. Да, может быть сложновато разобраться в настройках стилей и плагинов, и в целом это приложение, которое нужно допиливать под себя. Да, нет встроенной бесплатной синхронизации, и её нужно настраивать отдельно. Зато после настройки всё работает безупречно. Я до сих пор продолжаю пробовать разные приложения для заметок, просто из любопытства, чтобы посмотреть на какие-то новые функции и возможности, однако после Обсидиана это всё уже не то. В конечном итоге локальность, скорость, гибкость и кастомизируемость перебивает для меня любые другие фишечки, даже то, которых, может быть, у Обсидиана пока нет.\n"},{"id":3,"href":"/typing-transformer/","title":"Как упростить ввод текста в Обсидиане (плагин Typing transformer)","section":"Paperless Forest","content":"Основное #   Typing transformer — один из моих самых любимых плагинов в Обсидиане, без которых я абсолютно не могу обойтись. Однако его незаслуженно обходят вниманием — я ни разу не видела, чтобы кто-то о нём писал. Поэтому я решила написать небольшой обзор.\nЧто делает Typing transformer? Когда вы вводите какой-нибудь текст, он на ходу превращает его в другой текст. При этом превращение происходит по вашим собственным правилам, которые вы пропишете с настройках. Плагин можно использовать:\n чтобы вводить латинские буквы или редкие символы в русской раскладке; чтобы вводить длинные слова или сложные сочетания символов, нажав всего пару клавиш; чтобы автоматически удваивать парные символы, которые не поддерживаются Обсидианом (например, кавычки-ёлочки); чтобы делать любые другие автозамены, которые вы сможете придумать.  Плагин был разработан для китайского языка, но и с русским языком он работает прекрасно. Главное, после установки изменить некоторые настройки, потому что по умолчанию там прописаны китайские правила, которые могут ломать русский текст.\nКак настроить плагин #  Прежде всего, я рекомендую отключить настройки «Auto format» и «Zone indicator».\nЗатем в разделе «Rules» удяляем все правила. Это китайские правила, которые нам не нужны. Вместо этого мы пропишем свои собственные правила. Их можно добавлять сколько угодно.\nПравила пишутся с помощью очень простого синтактиса. К примеру, если мы хотим, чтобы слово «првт» автоматически превращалось в «привет», то пишем такую строку:\n\u0026#39;првт|\u0026#39; -\u0026gt; \u0026#39;привет|\u0026#39; Обратите внимание на вертикальную черту. Она символизирует положение курсора и обязательно должна присутствовать. Мы можем переместить курсор в другое место. Например, если мы хотим, чтобы слово «првт» превращалось в «привет», но при этом курсор бы оказывался между «при» и «вет», то пишем такое правило:\n\u0026#39;првт|\u0026#39; -\u0026gt; \u0026#39;при|вет\u0026#39; Это удобно для ввода парных символов вроде кавычек или скобок, потому что мы хотим, чтобы курсор оказывался между ними. Вот, например, реальное правило, которое я использую: при вводе трёх обычных кавычек они превращаются в кавычки-ёлочки с курсором посередине:\n\u0026#39;\u0026#34;\u0026#34;\u0026#34;|\u0026#39; -\u0026gt; \u0026#39;«|»\u0026#39; Можно также прописать правила для быстрого удаления слов. Скажем, у нас есть слово «привет» и мы хотим, чтобы при удалении буквы «т» удалялось бы автоматически всё слово. Можно использовать такое правило (заметьте, что вместо стрелочки используются символы «-x»):\n\u0026#39;привет|\u0026#39; -x \u0026#39;|\u0026#39; Это тоже удобно использовать для парных символов. К примеру, у нас есть кавычки-ёлочки, и мы хотим, чтобы при удалении первой кавычки автоматически удалялась и вторая:\n\u0026#39;«|»\u0026#39; -x \u0026#39;|\u0026#39; Ещё можно прописать правило для оборачивания выделения в какие-то символы. Например, с помощью такого правила можно выделить текст, ввести букву «d», и текст автоматически обернётся в html-тэг div:\n\u0026#39;d\u0026#39; -\u0026gt; \u0026#39;\u0026lt;div\u0026gt;\u0026#39; + \u0026#39;\u0026lt;/div\u0026gt;\u0026#39; Как видите, настройка очень простая, однако при прописывании правил нужно быть осторожнее. Автозамена срабатывает автоматически, не спрашивая пользователя, и отменить её нельзя. Поэтому нужно стараться не прописывать с левой стороны те сочетания символов, которые вам могут понадобиться сами по себе. Альтернативный метод — прописать дополнительные правила для обратного превращения.\nК примеру, мы прописали правило, превращающее слово «првт» в «привет». Но что если нам понадобится написать именно «првт»? С существующим правилом это сделать довольно сложно. Но можно прописать дополнительное правило, которое будет превращать «привет» обратно в «првт» при добавлении какого-нибудь символа, скажем, звёздочки:\n\u0026#39;привет*|\u0026#39; -\u0026gt; \u0026#39;првт|\u0026#39; Правила не поддерживают регулярные выражения, но можно использовать экранирование для некоторых символов (например, чтобы ввести вертикальную черту, нужно будет написать символы «\\|»), а также можно использовать «\\n» для обозначения перевода строки.\nВ плагине также можно настроить профили. Это разные режимы, в которых будут применяться разные правила и между которыми можно переключаться. Я не использую профили, но они могут быть полезны в некоторых случах. Например, если в каких-то заметках вы пишете много кода, можно включить профиль с автозаменами для кода, и отключать его при работе с другими заметками.\nМои правила #  Главная прелесть плагина в том, что можно настроить все правила под себя, в точности так, как тебе удобно вводить текст. Вот некоторые правила, которые я настроила для себя, и которые очень сильно упрощают мне жизнь. Я старалась придумывать правила так, чтобы они были интуитивно понятны и легко запоминались.\n# Тройная кавычка превращается в кавычки-ёлочки. \u0026#39;\u0026#34;\u0026#34;\u0026#34;|\u0026#39; -\u0026gt; \u0026#39;«|»\u0026#39; # Удаление первой ёлочки удаляет и вторую. \u0026#39;«|»\u0026#39; -x \u0026#39;|\u0026#39; # Обернуть выделение в кавычки-ёлочки (правила для выделения не поддерживают несколько символов, поэтому вместо кавычек используем двойку. \u0026#39;2\u0026#39; -\u0026gt; \u0026#39;«\u0026#39; + \u0026#39;»\u0026#39; # Заменить два минуса на тире. \u0026#39;--|\u0026#39; -\u0026gt; \u0026#39;—|\u0026#39; # Добавляем звёздочку, чтобы обратно превратить тире в два минуса (иногда нужно для написания кода). \u0026#39;—*|\u0026#39; -\u0026gt; \u0026#39;--|\u0026#39; # Тире и минус превращаются в три минуса. \u0026#39;—-|\u0026#39; -\u0026gt; \u0026#39;---|\u0026#39; # Вводим №№, чтобы получить #. \u0026#39;№№|\u0026#39; -\u0026gt; \u0026#39;#|\u0026#39; # Одинарный № после # тоже превращается в #, чтобы упростить ввод нескольких хэштэгов подряд (полезно для заголовков). \u0026#39;#№|\u0026#39; -\u0026gt; \u0026#39;##|\u0026#39; # Вводим четыре кавычки, чтобы получить @ (с учётом того, что три кавычки превращаются в ёлочки). \u0026#39;«\u0026#34;|»\u0026#39; -\u0026gt; \u0026#39;@|\u0026#39; # Доллар в русской раскладке (;;). \u0026#39;;;|\u0026#39; -\u0026gt; \u0026#39;$|\u0026#39; # Шапочка в русской раскладке (:::). \u0026#39;:::|\u0026#39; -\u0026gt; \u0026#39;^|\u0026#39; # Амперсанд в русской раскладке (??). \u0026#39;??|\u0026#39; -\u0026gt; \u0026#39;\u0026amp;|\u0026#39; # Вводим скобки в русской раскладке. # «хх» превращается в двойные квадратные скобки. \u0026#39;хх|\u0026#39; -\u0026gt; \u0026#39;[[|]]\u0026#39; # Вводим звёздочку внутри крадратных скобок, чтобы отменить превращение. \u0026#39;[[*|]]\u0026#39; -\u0026gt; \u0026#39;хх|\u0026#39; # Вводим х, чтобы обернуть выделенный текст в квадратные скобки. \u0026#39;х\u0026#39; -\u0026gt; \u0026#39;[\u0026#39; + \u0026#39;]\u0026#39; # Чтобы вставить внешнюю ссылку, можно ввести «хъ() », «хъ90» или «[]90». В первом случае нужен пробел после скобок, потому что плагин не понимает правил, заканчивающихся на скобку. \u0026#39;хъ() |\u0026#39; -\u0026gt; \u0026#39;[|]()\u0026#39; \u0026#39;хъ90|\u0026#39; -\u0026gt; \u0026#39;[|]()\u0026#39; \u0026#39;[]90|\u0026#39; -\u0026gt; \u0026#39;[|]()\u0026#39; # Чтобы обернуть текст во внешнюю ссылку, выделяем его и вводим 9. \u0026#39;9\u0026#39; -\u0026gt; \u0026#39;[\u0026#39; + \u0026#39;]()\u0026#39; # Вводим парные бэктики в русской раскладке (ёё для одинарных кавычек, ёёё для тройных). \u0026#39;ёё|\u0026#39; -\u0026gt; \u0026#39;`|`\u0026#39; \u0026#39;`ё|`\u0026#39; -\u0026gt; \u0026#39;```|\\n```\u0026#39; # Оборачиваем выделение в одинарные бэктики (выделить и ввести букву ё). \u0026#39;ё\u0026#39; -\u0026gt; \u0026#39;`\u0026#39; + \u0026#39;`\u0026#39; # Вводим тильды в русской раскладке(ЁЁ - одинарная тильда, ЁЁЁ — двойные парные тильды). \u0026#39;ЁЁ|\u0026#39; -\u0026gt; \u0026#39;~|\u0026#39; \u0026#39;~Ё|\u0026#39; -\u0026gt; \u0026#39;~~|~~\u0026#39; # Оборачиваем выделение в одинарные тильды (выделить и ввести букву Ё). \u0026#39;Ё\u0026#39; -\u0026gt; \u0026#39;~\u0026#39; + \u0026#39;~\u0026#39; # Введение чекбоксов в русской и английской раскладке. # Вводить чекбоксы довольно неудобно, потому что они состоят из пяти символов и легко можно забыть какой-нибудь пробел. Я прописала такие правила, чтобы можно было ввести всего несколько первых символов чекбокса, и даже без пробелов. # Русская раскладка (вводим «- хъ» или просто «-х»). \u0026#39;- хъ|\u0026#39; -\u0026gt; \u0026#39;- [ ] |\u0026#39; \u0026#39;-х|\u0026#39; -\u0026gt; \u0026#39;- [ ] |\u0026#39; # Если нам нужен текст «-х», то можно отменить превращение, удалив пробел после чекбокса и введя букву «х». \u0026#39;- [ ]х|\u0026#39; -\u0026gt; \u0026#39;-х|\u0026#39; # Английская раскладка: вводим «-[ », «- [ », «-[] », «- [] » (обязательно пробел после последней скобки). \u0026#39;-[ |]\u0026#39; -\u0026gt; \u0026#39;- [ ] |\u0026#39; \u0026#39;- [ |]\u0026#39; -\u0026gt; \u0026#39;- [ ] |\u0026#39; \u0026#39;-[] |\u0026#39; -\u0026gt; \u0026#39;- [ ] |\u0026#39; \u0026#39;- [] |\u0026#39; -\u0026gt; \u0026#39;- [ ] |\u0026#39; # Упрощаем ввод знаков \u0026gt; и \u0026lt;. # В русской раскладке «ЮЮ» превращается в «\u0026gt;», а «ББ» превращается в «\u0026lt;». \u0026#39;ЮЮ|\u0026#39; -\u0026gt; \u0026#39;\u0026gt;|\u0026#39; \u0026#39;ББ|\u0026#39; -\u0026gt; \u0026#39;\u0026lt;|\u0026#39; # Быстрая вставка коллаута. Вводим «\u0026gt;..» или «\u0026gt;//», чтобы получить «\u0026gt;[!]». \u0026#39;\u0026gt;..|\u0026#39; -\u0026gt; \u0026#39;\u0026gt;[!|]\u0026#39; \u0026#39;\u0026gt;//|\u0026#39; -\u0026gt; \u0026#39;\u0026gt;[!|]\u0026#39; # Чтобы напечатать вертикальную черту в русской раскладке, вводим обратную косую черту и пробел: «\\ ». \u0026#39;\\ |\u0026#39; -\u0026gt; \u0026#39;\\||\u0026#39; # Я очень часто использую датавью, поэтому прописала правила для сокращённого ввода слов dataview и dataviewjs. \u0026#39;```dv|\u0026#39; -\u0026gt; \u0026#39;```dataview|\u0026#39; \u0026#39;```dj|\u0026#39; -\u0026gt; \u0026#39;```dataviewjs|\u0026#39; Правил довольно много, но я статалась сделать так, чтобы в русской раскладке для ввода символов использовались те же клавиши, что и в английской, а сокращения были очевидны, поэтому в них не запутаешься, и легко привыкнуть ими пользоваться.\n"},{"id":4,"href":"/obsidian-random-notes/","title":"Мои наблюдения по опыту использования Обсидиана","section":"Paperless Forest","content":"Я использую Обсидиан уже два года, и постоянно пробую в нём что-то новое. В этом посте буду собирать список рандомных заметок о том, что для меня работает, а что нет, и других кратких наблюдений по опыту использования.\n Дашборды красивые, я сделала несколько очень крутых дашбордов, и с датавью, и попроще, но в итоге я их практически никогда не использую. Для навигации чаще всего использую поиск по названию и алиасам. Можно делать это с помощью Quick Switcher-а но я чаще использую поисковую строку в плагине Home tab. Typing transformer использую постоянно, один из самых полезных плагинов, о которых никто не говорит. Ежедневные заметки использую постоянно в качестве инбокса. Позволяют не думать, куда записать мысль. В ежедневных заметках нет никакой структуры, пишу всё подряд в виде списка. Когда пробовала делать структуру, поняла, что не использую её. Одно время пыталась вести задачи в Обсидиане. Даже выстроила неплохую систему, но потом поняла,что пытаюсь в этой системе эмулировать всё то, что уже есть в специальных приложениях для задач из коробки, только в них оно работает проще и лучше. Плюнула и перенесла задачи в Ticktick. Держу в Обсидиане списки задач по проектам без срока исполнения или формата «может быть когда-нибудь». Всё, что с датой, идёт в TickTick. Коллекции книг, фильмов и т.п., с табличками с всем таким, красивые, но довольно бесполезные. Но красивые. Пробовала обойтись без папок, не понравилось. Но папок должно быть немного, и деление по папкам не по темам, а по типам или сферам использования. Пробовала несколько существующих плагинов для отслеживания писательского прогресса. Ни один не понравился. Пишу свой плагин. Навострилась писать скрипты для dataviewjs, фигачу их везде. Обычный dataview уже не помню, как использовать. Настройка css — бесконечный процесс, приводящий к прокрастинации. Написала свою тему, но всё равно есть ещё куча сниппетов, которые постоянно допиливаю. Много раз пыталась встроить в свою систему тэги, но ничего не получается. Предпочитаю свойства и ссылки. Поиск по тексту не очень удобный, поэтому стараюсь так выстраивать систему, чтобы приходилось его использовать по минимуму. Пробовала использовать несколько хранилищ. Для постоянного использования не очень удобно. В любой момент может возникнуть необходимость сделать рандомную заметку, и непонятно, в какое хранилище её добавлять. Не хочу забыть, где что лежит. Плюс неудобно переключаться между хранилищами на телефоне. Пришла к системе трёх хранилищ:  Основное (все актуальные заметки) Архивное (все заметки, которые уже неактуальны, но удалять жалко) Тестовое (чтобы пробовать новые плагины, системы и т.п.)   Написала скрипт для автоматического переноса заметки из основного хранилища в архивное по команде. Выяснила, что Обсидиан хорошо работает с большим количеством заметок, если нет плагинов. Наличие плагинов (особенно датавью) здорово замедляет большие хранилища. Особенно заметно на телефоне. Поэтому стараюсь ограничивать количество заметок в основном хранилище, а всё отработанное переносить в архив. Работа Обсидиана на телефоне очень зависит от количества памяти. Я купила новый телефон с большой оперативкой, и теперь Обсидиан летает.  "},{"id":5,"href":"/how-to-add-sketches-to-obsidian/","title":"Как добавлять рисунки в Обсидиан","section":"Paperless Forest","content":"Иногда в свои заметки в Обсидиане хочется добавить какой-то скетч. Я пробовала плагин Ecxalidraw, пробовала другие приложения для рисования, но у меня нет стилуса, так что всё это было не очень-то удобно. В конце концов я пришла к мысли, что мне проще и быстрее нарисовать картинку или схему в блокноте и сфотографировать её. Блокнот у меня всегда с собой, а рисую я чёрным линером для большей чёткости.\n Чёрно-белая картинка хорошо смотрится на белом фоне, но на цветном фоне или при использовании тёмной темы слишком уж выделяется. Но вот в этом видео я увидела идею, как подогнать цвета картинки под цвет темы Обсидиана. У автора видео это всё выглядит сложновато, так что для себя я всё немного упростила. Вот как это может выглядеть в светлой или тёмной теме:\n![[./images/Скриншот добавление рисунков светлая тема перекраска.jpg|250]] ![[./images/Скриншот добавление рисунков тёмная тема перекраска.jpg|250]]\nЧтобы добиться такого эффекта, сначала картинку нужно сделать прозрачной. Для этого надо удалить с неё белый фон. Это можно сделать в Фотошопе, но за неимением Фотошопа я использую paint.net.\nПредварительно я обрабатываю изображение фильтрами, чтобы сделать его чёрно-белым с максимальной контрастностью, без лишних оттенков. Это сделает очистку фона эффективнее. Это я обычно проделываю уже в момент фотографирования, на телефоне, с помощью встроенных инструментов камеры и галереи.\nЧтобы затем удалить фон в paint.net нужно выбрать инструмент «волшебная палочка», заполнение: глобальное, чувствительность: 40%. Затем кликнуть по белому фону и нажать delete. Должно удалиться всё белое. Сохранить файл в формате png для сохранения прозрачности.\nЗатем файл картинки нужно переименовать, добавив в любое место названия текст «recolor-image». Этот текст будет сигнализировать о том, что изображение должно перекрашиваться под тему (потому что мы не хотим, чтобы перекрашивались вообще все картинки).\nПоскольку фон картинки прозрачный, его перекрашивать не нужно. Но нужно добавить фильтры для перекрашивания текста и линий на рисунке. Это особенно актуально для тёмной темы. Я хочу, чтобы цвет рисунка соответствовал цвету шрифта. Для этого нужно подключить css-сниппет:\n.theme-light { --image-filter: \u0026lt;фильтр для светлой темы\u0026gt;; } .theme-dark { --image-filter: \u0026lt;фильтр для тёмной темы\u0026gt;; } .image-embed[src*=\u0026#34;recolor-image\u0026#34;] img { filter: var(--image-filter); } К сожалению, фильтры не высчитываются автоматически, и придётся их прописывать вручную для каждой темы. Для этого:\n Определяем цвет шрифта или любой другой желаемый цвет рисунка в формате HEX или RGB; Открываем генератор, вставляем в него код желаемого цвета и генерируем фильтр. Полученные параметры фильтра подставляем в переменную --image-filter.  После этого чёрный цвет на картинке отфильтруется и превратится в нужный нам цвет.\nДополнение: Есть ещё другой способ, без использования генератора. Добавляем фильтр в формате svg:\n--image-filter: url(\u0026#39;data:image/svg+xml;utf8,\\ \u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34;\u0026gt;\\ \u0026lt;filter id=\u0026#34;recolor\u0026#34; color-interpolation-filters=\u0026#34;sRGB\u0026#34;\u0026gt;\\ \u0026lt;feColorMatrix type=\u0026#34;matrix\u0026#34; values=\u0026#34;\\ 0 0 0 0 R\\ 0 0 0 0 G\\ 0 0 0 0 B\\ 0 0 0 A 0\\ \u0026#34;/\u0026gt;\\ \u0026lt;/filter\u0026gt;\\ \u0026lt;/svg\u0026gt;\\ #recolor\u0026#39;); При этом буквы RGBA нужно заменить на соответствующие выбранному цвету. Для этого нам нужно получить код цвета в формате rgb или rgba, например: rgba(74, 52, 28, 0.9). Первые три значения делим на 255, четвёртое оставляем без изменений и в таком виде подставляем в матрицу. Получаем:\n0 0 0 0 0.29\\ 0 0 0 0 0.2\\ 0 0 0 0 0.11\\ 0 0 0 0.9 0\\ Стоит учитывать, что при делении приходится округлять, поэтому, как и в первом случае, цвет может совпадать не на сто процентов.\n"},{"id":6,"href":"/how-to-create-site/","title":"Как создать бесплатный статический сайт из заметок Obsidian","section":"Paperless Forest","content":"Преамбула #  В приложении Obsidiian есть встроенный сервис Publish, который позволяет создать свой сайт и публиковать заметки в интернете в один клик. Но у него есть как плюсы, так и минусы.\nПлюсы:\n минимум настроек, всё работает из коробки; поддерживается весь основной функционал Обсидиана.  Минусы:\n он платный (и довольно дорогой); ограниченные возможности настройки сайта.  К счастью, есть бесплатные альтернативы, которые, вдобавок, дают гораздо больше контроля над внешним видом и функционалом сайта. Минусом этих альтернатив можно считать то, что придётся изрядно повозиться с настройкой.\nЭтот мой сайт сделан совершенно бесплатно (я только заплатила сто рублей за домен, но даже это было необязательно). Он хостится на Github Pages и создан при помощи генератора статических сайтов Hugo. Но главное — новые страницы публикуются напрямую из Обсидиана, одной командой. В этой статье я расскажу, как можно сделать подобный сайт самостоятельно.\nОбщая информация #  Генерация сайта происходит в два этапа. Во-первых, нужно отправить заметку из Обсидиана в репозиторий на гитхабе. Во-вторых, добавленные Markdown-файлы нужно преобразовать в Html-страницы и собрать из них сайт. Для первого этапа нам понадобится установить плагин для Обсидиана Github Publisher. За второй будет отвечать специальный шаблон, который мы разместим в репозитории. Шаблон будет применяться автоматически каждый раз при добавлении нового файла.\nНачать настройку сайта лучше всего с выбора шаблона. Шаблон — это набор правил, по которым кучка маркдаун-файлов преобразуется в сайт. Он определяет внешний вид и функционал сайта: расположение элементов, меню и иконки, стили, скрипты и т. п., а также правила, по которым синтаксис Markdown преобразуется в Html. В интернете можно найти огромное количество шаблонов для статических сайтов, но не все они поддерживают специфический синтаксис Обсидиана, поэтому лучше всего выбирать шаблон, специально заточенный под Обсидиан. Популярным вариантом является Quartz. Ещё можно попробовать Mkdocs или Amethyst. Мой сайт сделан на основе шаблона Amethyst, но его я не рекомендую, потому что он сильно устаревший, и мне пришлось его очень здорово переписать под себя. Может быть, когда-нибудь я напишу и опубликую документацию к собственному шаблону (пока что он сыроват).\nВ целом любые шаблоны устанавливаются и работают примерно одинаково, но могут иметь небольшие отличия в настройках, поэтому придётся читать документацию к конкретному выбранному шаблону. Я опишу установку на примере шаблона Quartz, хотя сама его не использую, но он наиболее актуальный из доступных.\nСоздание и настройка сайта на базе Quartz #  Установка шаблона на Github Pages #  Вот самый простой способ быстро создать сайт на базе Quartz:\n Зарегистрироваться на Github (если ещё нет аккаунта). Открыть репозиторий шаблона и нажать кнопку «Use this template». Создать новый публичный репозиторий. Переименовать ветку v4 в main. Отредактировать файл deploy.yml в папке .github/workflows, удалив строку token: ${{ secrets.GH_PAT }}. Перейти на страницу Settings —\u0026gt; Pages и выбрать Source —\u0026gt; Github Actions. Перейти на страницу Settings —\u0026gt; Environments — удалить все. В папке content создать файл index.md. Он обязательно должен содержать фронтмэттер со свойством title, содержащим заголовок для главной страницы. Снова перейти на страницу Settings —\u0026gt; Pages. Там появится ссылка на ваш новый сайт.  Настройка сайта #  Теперь для настройки сайта необходимо отредактировать файл quartz.config.ts. В нём нужно изменить следующие свойства:\n pageTitle — указать своё название сайта; locale — поменять на \u0026quot;ru-RU\u0026quot;; baseUrl — здесь нужно указать свой адрес сайта (без \u0026quot;https://\u0026quot;); theme — здесь можно заменить шрифты и цвета на какие вам хочется.  Дополнительно можно поменять внешний вид сайта:\n отредактировав файл quartz.layout.ts— можно поменять расположение элементов на сайте; отредактировав scss-файлы в папке quartz/styles.  Больше о настройках можно узнать в документации Quartz\nДля добавления новых страниц на сайт Markdown-файлы должны добавляться в папку content. При этом каждый Markdown-файл должен как минимум содержать свойство title. Далее мы настроим, чтобы эти файлы туда добавлялись автоматически из Обсидиана.\nЛокальная копия сайта #  Редактировать файлы сайта можно прямо на гитхабе (что не очень удобно и медленно, но зато не нужно ничего скачивать и устанавливать). Либо можно скопировать их на свой компьютер с помощью Git и редактировать локально.\nЧтобы запустить локальную копию сайта для отладки:\n Установите Git. Установите Node (после установки требуется перезагрузить компьютер). В своём репозитории скопируйте адрес для клонирования (Code —\u0026gt; HTTPS —\u0026gt; копировать) Откройте терминал и введите команду:  git clone \u0026lt;скопированный адрес\u0026gt; После этого все файлы с гитхаба скопируются в папку с названием репозитория на вашем компьютере, где их можно будет удобно редактировать. Когда всё скопируется, введите команды:\ncd \u0026lt;название скопированной папки\u0026gt; npx quartz build --serve Эта команда запускает сайт на локальном сервере. В браузере откройте адрес http://localhost:8080/. Это локальная версия сайта, где будут сразу отображаться все изменения, которые вы сделаете в скопированных файлах.\nПосле того, как настройка закончена, можно отправить отредактированные файлы обратно на гитхаб с помощью команд:\ngit add --a git commit -m \u0026#34;My cool new changes\u0026#34; git push origin main Собственный домен #  По умолчанию адрес сайта на Github Pages отображается в формате \u0026lt;имя аккаунта\u0026gt;.github.io/\u0026lt;название репозитория\u0026gt;, но если вы хотите адрес покрасивее, то можно купить и настроить свой собственный домен. Как это сделать, я рассказывать не буду, потому что нашла очень доступную и внятную статью об этом.\nНастройка Gihub Publisher #  Теперь, когда сайт готов, нужно добавить возможность публиковать новые страницы напрямую из Обсидиана. Для этого нужно будет настроить в Обсидиане плагин Gihub Publisher.\n Установливаем плагин На гитхабе переходим на страницу Settings — Developer settings — Personal access tokens — Fine-grained tokens — Generate new token. Придумываем название токена, указываем продолжительность действия и репозитории, к которым он применяется (лучше указать только репозиторий сайта). Затем указываем разрешения для репозитория. Их очень много, и они непонятные, поэтому лично я просто выставляю максимальные разрешения на всё. После генерации токен обязательно нужно где-то сохранить, потому что второй раз вам его не покажут. Открываем настройки Github Publisher и указываем следующие данные:  Вкладка Github config:  Имя своего аккаунта на гитхабе. Название репозитория. Токен.   Вкладка File paths:  Default folder — content. Root folder — content.   Вкладка Content:  Internals links — да. Convert internal links pointing to unpublished notes — да. Wikilinks to MDlinks — нет.   Attachment \u0026amp; embeds:  Send linked files — нет. Transfer attachments — да. Остальные настройки указываются по желанию. Дополнительно о возможностях плагина можно почитать в документации.      Публикация заметок #  Теперь можно публиковать заметки. Нужно создать заметку и добавить к ней свойство share: true, а также свойство title для заголовка. Можно добавить и другие свойства (в соответствии с настройками плагина и встроенными свойствами, указанными в документации Quartz), но эти обязательные. После этого в палитре команд вызываем команду Upload single current active note.\nЕсли всё настроено правильно, то появится сообщение, что заметка опубликована. Для проверки можно зайти в репозиторий и убедиться, что заметка добавилась в папку content. Обычно после этого нужно с полминуты подождать прежде чем страница отобразится на сайте.\nЕсли заметка добавилась на гитхаб, но на сайте не появляется, можно открыть в репозитории вкладку Actions и посмотреть, какие процессы там происходят. Если последний процесс отображается с красным крестиком, значит, при генерации сайта произошла ошибка, и там можно прочитать, что именно пошло не так.\nЗаключение #  Надеюсь, это будет кому-нибудь полезно! Я сама не использую Quartz, потому что узнала о нём только после того, как практически написала собственный шаблон на Hugo, но я его тестировала, и он выглядит очень неплохо. Вдобавок, по тому же принципу можно настроить любой другой шаблон, будь то Hugo, Jekyll и так далее. Я перепробовала несколько разных вариантов, и, когда усвоишь общую идею, разница невелика.\nЯ сама не очень-то программист, и мне пришлось местами поломать голову, разбираясь во всех нюансах настройки, несмотря на наличие документации. Поэтому я постаралась расписать весь процесс максимально подробно, но при этом не вдаваясь в лишние дебри, чтобы инструкция была понятна даже людям, не слишком разбирающимся в гитхабе и прочих технологиях.\n"},{"id":7,"href":"/tags/","title":"Тэги","section":"Paperless Forest","content":"tags\n"},{"id":8,"href":"/syncthing/","title":"Syncthing","section":"Paperless Forest","content":"Приложение для синхронизации файлов между устройствами (напрямую, без облаков).\nПреимущества Syncthing #   Синхронизация очень быстрая. Файлы не хранятся нигде в облаках и на чужих серверах, а только на моих устройствах. Есть версионирование и отслеживание конфликтов, что позволяет восстанавливать потерянные данные. Синхронизация возможна даже без интернета (например, по локальной сети). Работает на любых устройствах (я даже ухитрилась впихнуть Syncthing на свою читалку Pocketbook). Можно синхронизировать любые папки на устройстве, независимо от их расположения (в том числе даже на флэшке). Бесплатная синхронизация любых объёмов данных без ограничений. Опенсорсный проект.  Недостатки Syncthing #   Очень много не совсем понятных настроек, в которых легко запутаться, особенно не технарю. Иногда бывают конфликты с удалёнными файлами при синхронизации нескольких устройств.  "},{"id":9,"href":"/change-history/","title":"История изменений","section":"Paperless Forest","content":"15 мая 2024 #   Улучшила цвета блоков кода. Пофиксила цвет ссылок. Немного поправила отступы и шрифты.  14 мая 2024 #   [[./how-to-create-site|Как создать бесплатный статический сайт из заметок Obsidian]]  13 мая 2024 #   Добавила коллауты-списки. Удалила лишние страницы.  Теперь на сайте не будет новостных постов. Все обновления сайта будут отображаться на этой странице, а текущие мысли и идеи — публиковаться в мастодоне.    08 мая 2024 #   Добавила виджет для отображения последних записей на Mastodon.  18 марта 2024 #   Создала эту страницу для отслеживания истории изменений на сайте.  29 февраля 2024 #   [[./digital-garden|Цифровой сад]]  23 января 2024 #   Переделала структуру сайта. Теперь все страницы (кроме блог-постов) лежат в корне сайта. Это упрощает ссылки и помогает сохранять их неизменными. Временно сломана иерархия в меню навигации. Починила меню. Теперь папки в меню работают, но больше не связаны с фактической структурой сайта, так что я могу менять их произвольно, не ломая при этом ссылки. Убрала всплывающие окошки для предпросмотра страниц при наведении на ссылку. Они , конечно, прикольные, но на мой взгляд больше мешаются и раздражают. Поправила стили для коллаутов.  21 января 2024 #   [[./Canvas-style-menu-settings|Пресет настроек для плагина Canvas Style Menu]]  18 декабря 2023 #   Пофиксила добавление картинок и сделала стиль блога чуть более минималистичным.  17 декабря 2023 #   [[./sidebar-images|Css для картинок в сайдбаре]]  16 декабря 2023 #   [[./how-to-reuse-dataviewjs-code|Как переиспользовать код с помощью dataviewjs]]  03 октября 2023 #   Сайт получил собственный домен: paperless-forest.ru.  02 октября 2023 #   Добавила на сайт бэклинки. Добавила предпросмотр ссылки при наведении. Доработала стили.  29 сентября 2023 #   Добавила на сайт функциональные тэги. Доработала ленту блога.  19 сентября 2023 #   [[./sync-syncthing-without-internet|Синхронизация через Syncthing без интернета]]  11 сентября 2023 #   Окончательно запустила новый сайт! 🎉  09 сентября 2023 #   [[./about|Обо мне]]  08 сентября 2023 #   [[../Obsidian|Obsidian]] [[./custom-checkboxes|Кастомные чекбоксы в Obsidian]]  07 сентября 2023 #   [[./_index|Главная страница сайта]] [[./three-act-structure|Трёхактная структура]] [[./obsidian-quickadd-how-to-run-scripts|Obsidian QuickAdd - как запускать скрипты]] [[./pocketbook-collection-manager|Менеджер коллекций для Покетбука]]  "},{"id":10,"href":"/digital-garden/","title":"Цифровой сад","section":"Paperless Forest","content":"Цифровой сад (digital garden) — это личный сайт, где можно делиться своими мыслями. Отличием цифрового сада от блога является то, что записи не выстроены в хронологической последовательности, и их можно просматривать в любом порядке при помощи перекрёстных ссылок и тэгов, по принципу Википедии. Записи в цировом саду не обязательно являются законченными, а могут постепенно дополняться и уточняться.\nМой сайт является цифровым садом наполовину: в нём есть лента блога, но она существует отдельно от основных записей, которые не привязаны к хронологии.\nСсылки на интересные цифровые сады:\n  Fork My Brain  Maggie Appleton  Andy Matuschak  Русскоязычные:\n  Цифровой сад  "},{"id":11,"href":"/Canvas-style-menu-settings/","title":"Пресет настроек для плагина Canvas Style Menu","section":"Paperless Forest","content":"Недавно появился ещё пока неофициальный плагин для Обсидиана, Canvas Style Menu, который расширяет меню редактирования карточки на холсте. С его помощью можно не только изменять цвет карточек, но и добавлять к ним любые другие стили. Правда, по умолчанию там довольно мало настроек, но можно добавить свои настройки самостоятельно. Я долго ковырялась, но наконец настроила все правила, какие мне хотелось. Если вдруг кому тоже хочется делать в канвасе красивое, но неохота копаться в настройках и css, делюсь своим пресетом:\n Установите плагин через BRAT. Если устанавливали раньше, обновите, там появились новые фишечки. Скачайте этот файл и положите его в папку .obsidian/plugins/canvas-style-menu/packages. Создайте, если её нет. Скачайте и подключите сниппет. В настройках плагина нажмите кнопку Reload packages и выберите пакет CSM Reaty settings Стили вдохновлялись частично Canvas Candy, частично самим плагином, но кое-что я добавила от себя. Весь функционал можно посмотреть на картинке:   "},{"id":12,"href":"/sidebar-images/","title":"Css для картинок в сайдбаре","section":"Paperless Forest","content":"Иногда хочется украсить свой Обсидиан картинками, но чтобы это смотрелось ненавязчиво. Я не очень люблю фоновые картинки и баннеры в заметках, но мне нравится добавлять картинки в боковую панель.\nДля этого нужно сперва добавить файл изображения в хранилище, открыть его, а затем перетащить и закрепить в боковой панели, над или под основными вкладками.\nНо по умолчанию такая картинка смотрится не очень хорошо, потому что получаются лишние отступы, и верхняя панель занимает слишком много места. Вот как это выглядит:\n Чтобы улучшить отображение картинки я написала такой css-сниппет:\n:is(.mod-left-split, .mod-right-split) .workspace-tabs:has(.image-container):not(.mod-active) .workspace-tab-header-container { display: none; } :is(.mod-left-split, .mod-right-split) .workspace-tabs:has(.image-container) { max-height: 150px;; } :is(.mod-left-split, .mod-right-split) .workspace-tabs:has(.image-container) .workspace-tab-container .view-content { padding: 0; overflow: hidden; } :is(.mod-left-split, .mod-right-split) .workspace-tabs:has(.image-container):not(.mod-active) .workspace-tab-container .view-content .image-container { padding-top: 5px; } :is(.mod-left-split, .mod-right-split) .workspace-tabs:has(.image-container) .workspace-tab-container .view-content .image-container { width: 100%; height: 100%; } :is(.mod-left-split, .mod-right-split) .workspace-tabs:has(.image-container) .workspace-tab-container .view-content img { width: 100%; height: 100%; object-fit: cover; } После подключения сниппета картинка выглядит так:\n Теперь она занимает всю область, без отступов, и выглядит более стильно. Верхняя панель скрыта и будет появляться только при клике на картинку.\n"},{"id":13,"href":"/how-to-reuse-dataviewjs-code/","title":"Как переиспользовать код с помощью dataviewjs","section":"Paperless Forest","content":"Иногда код dataviewjs получается слишком большим, или один и тот же кусок кода нужно использовать несколько раз в разных местах. Поэтому хочется не писать его весь в заметке, а часть кода вынести в отдельный модуль.Теоретически это можно сделать при помощи стандартного метода require, но проблема в том, что он не работает на мобильном.\nРаньше я использовала для этого плагин CustomJS, но теперь выяснила, как можно обойтись стандартным функционалом Dataview.\nДля этого используется функция dv.view().\nСначала создаём файл с расширением .js, например, my_сode.js, и кладём его в любое место в своём хранилище Обсидиана. Для примера положим его в папку scripts. Пишем в нём весь код, который хотим переиспользовать. Например, напишем там следующий код:\ndv.paragraph(\u0026#34;Hello world!\u0026#34;) Затем в заметке в блоке dataviewjs пишем:\nawait dv.view(\u0026#34;scripts/my_code\u0026#34;) При этом весь код, содержащийся в файле my_code.js автоматически исполняется и рендерится. Но что если мы не хотим ничего сразу рендерить, а хотим вернуть какие-то функции или переменные, которые можно использовать позже? Это можно сделать следующим образом.\nВ файле my_code.js пишем:\nthis.myFunc = (x) =\u0026gt; { dv.paragraph(x) } this.myVar = \u0026#34;Hello world!\u0026#34; И в заметке в блоке dataviewjs пишем:\nawait dv.view(\u0026#34;scripts/my_code\u0026#34;) myFunc(myVar) Подобным же образом можно переиспользовать любые функции или переменные.\nЗамечание: При таком способе все функции и переменные присваиваются глобальному объекту window, что не очень безопасно, потому что можно случайно перезаписать какие-то существующие свойства или методы. Кажется, что безопаснее было бы использовать промежуточный объект.\nНапример, в файле my_code.js пишем:\nconst myFunc = (x) =\u0026gt; { dv.paragraph(x) } const myVar = \u0026#34;Hello world!\u0026#34; this.myObject = {myFunc, myVar} И в заметке в блоке dataviewjs пишем:\nawait dv.view(\u0026#34;scripts/my_code\u0026#34;) const {myFunc, myVar} = myObject myFunc(myVar) У объекта myObject должно быть уникальное имя, не совпадающее ни с одним из свойств объекта window, но с одним объектом это легче проконтролировать, чем со множеством функций и переменных, которые мы можем использовать.\nМожно также использовать класс вместо объекта. В файле my_code.js пишем:\nthis.myClass = class myClass { myFunc() { dv.paragraph(\u0026#34;Hello world!\u0026#34;) } } И в заметке в блоке dataviewjs пишем:\nawait dv.view(\u0026#34;scripts/my_code\u0026#34;) const newClass = new myClass newClass.myFunc() "},{"id":14,"href":"/sync-syncthing-without-internet/","title":"Синхронизация через Syncthing без интернета","section":"Paperless Forest","content":"Я наконец дозрела попробовать Syncthing для синхронизации [[./obsidian|Обсидиана]]. До этого меня останавливало, что там надо, чтобы устройства были в одной сети, а как это организовать вне дома без танцев с бубном, я не знала (всё, что там про какие-то сервера и порты вызывает у меня короткое замыкание в мозгу).\nМоя проблема в том, что мне надо синхронизировать файлы с рабочим компом. На работе у меня нет вайфая, стоит файервол с кучей ограничений, почти все настройки намертво заблокированы, а периодически админы вообще отключают интернет, мол, нефиг расходовать рабочий трафик попусту. Из-за этого большинство методов синхронизации у меня там не работало вообще или работало плохо (мне удалось настроить гит, но он был очень медленный). У меня была мысль раздать вайфай с телефона, но как назло мой провайдер недавно сделал раздачу интернета с телефона платной и жутко дорогой.\nНо недавно я узнала, что, оказывается, Syncthing может синхронизировать вообще без интернета! Достаточно точки доступа. То есть, план действий, такой:\n отключаем мобильный интернет на телефоне (чтобы не расходовать платный трафик); включаем на телефоне точку доступа; подключаем компьютер к этой точке доступа как к вайфаю; запускаем Syncthing.  Профит! Интернета на устройствах нет, но они синхронизируются. Минус способа в том, что приходится отключать интернет на телефоне и держать активной точку доступа, что не всегда удобно, но для быстрой синхронизации в начале и в конце рабочего дня — идеально. И при желании можно синхронизировать устройства хоть в лесу, где связи нет вообще.\n"},{"id":15,"href":"/about/","title":"Обо мне","section":"Paperless Forest","content":"Привет! Меня зовут Анастасия.\nПо образованию я филолог, работаю редактором, но кроме того интересуюсь технологиями, изучаю веб-программирование и французский язык, пишу книгу и увлекаюсь миллионом разных вещей.\nЯ интроверт, люблю фэнтези и котиков, люблю читать книжки, писать тексты и крафтить что-нибудь своими руками. Не очень люблю популярные соцсети, потому что от них слишком много шума. Поэтому решила лучше [[./how-to-create-site|завести собственный сайт]].\nВ последнее время моё сильнейшее увлечение — программа для заметок [[./obsidian|Обсидиан]], и все те безграничные способы, которыми её можно настроить для создания идеальной писательской среды.\nМои контакты:\n  Телеграм  Mastodon  GitHub  "},{"id":16,"href":"/obsidian/","title":"Obsidian","section":"Paperless Forest","content":" Obsidian — приложение для заметок в формате Markdown.\n"},{"id":17,"href":"/custom-checkboxes/","title":"Кастомные чекбоксы в Obsidian","section":"Paperless Forest","content":"В [[./obsidian|Обсидиане]] очень удобно использовать свои собственные чекбоксы, например, такие:\n![[./images/Скриншот кастомные чекбоксы.jpg|Скриншот кастомные чекбоксы.jpg]]\nЕсть темы для Обсидиана, которые уже поддерживают некоторые из подобных чекбоксов, но можно назначить свои собственные при помощи css:\ninput[data-task=\u0026#34;h\u0026#34;]:checked, li[data-task=\u0026#34;h\u0026#34;] \u0026gt; input:checked, li[data-task=\u0026#34;h\u0026#34;] \u0026gt; p \u0026gt; input:checked { --checkbox-marker-color: transparent; border: none; border-radius: 0; background-image: none; background-color: currentColor; -webkit-mask-size: var(--checkbox-icon); -webkit-mask-position: 50% 50%; color: var(--color-red); -webkit-mask-image: url(\u0026#34;data:image/svg+xml,%3Csvg xmlns=\u0026#39;http://www.w3.org/2000/svg\u0026#39; viewBox=\u0026#39;0 0 24 24\u0026#39; width=\u0026#39;18\u0026#39; height=\u0026#39;18\u0026#39; %3E%3Cpath fill=\u0026#39;none\u0026#39; d=\u0026#39;M0 0H24V24H0z\u0026#39;/%3E%3Cpath d=\u0026#39;M12.001 4.529c2.349-2.109 5.979-2.039 8.242.228 2.262 2.268 2.34 5.88.236 8.236l-8.48 8.492-8.478-8.492c-2.104-2.356-2.025-5.974.236-8.236 2.265-2.264 5.888-2.34 8.244-.228z\u0026#39;/%3E%3C/svg%3E\u0026#34;); } Ссылки на svg-иконки, которые подставляются в свойство \u0026ldquo;-webkit-mask-image\u0026rdquo;, можно брать, например, тут: Remix Icon\nЕсли надо сделать чекбокс некликабельным:\n.HyperMD-task-line[data-task=\u0026#34;h\u0026#34;] \u0026gt; .task-list-label, input[data-task=\u0026#34;h\u0026#34;], li[data-task=\u0026#34;h\u0026#34;] \u0026gt; input, li[data-task=\u0026#34;h\u0026#34;] \u0026gt; p \u0026gt; input { pointer-events: none; } Шаблон этого сайта поддерживает некоторые кастомные чекбоксы, но не все:\n [n] [n] [r] [r] [\u0026gt;] [\u0026gt;]  Безопаснее использовать буквы, а не символы.\n"},{"id":18,"href":"/three-act-structure/","title":"Трёхактная структура","section":"Paperless Forest","content":" #NB Шпаргалка для писателя  1 акт #    1% - Крючок\n Открывающая сцена, которая должна зацепить читателя.    Экспозиция\n Читатель знакомится с миром, героями и конфликтом. Обозначаются цели и ставки.    12% - Побуждающее событие\n Первое активное вмешательство конфликта в Нормальный мир. зов приключений для героя.    Завязка\n Складываются условия для окончательного вступления героя в конфликт. Нарастает напряжение.    25% - Первая переломная точка\n Герой покидает Нормальный Мир, получает цель и вступает в конфликт.    2 акт #    Реакция\n Герой пытается приспособиться к новым обстоятельствам.    37% - Первая точка фокусировки\n Напоминание о конфликте и появление подсказок.    Осознание\n Герой всё больше узнаёт об обстоятельствах и конфликте.    50% - Центральная точка\n Момент истины. Герою раскрывается природа конфликта.    Активное действие\n После получения ключевой информации герой переходит к решительным действиям.    62% - Вторая точка фокусировки\n Предвестие катастрофы и напоминание о ставках.    Обновлённая атака\n Герой действует ещё активнее и достигает ложной победы.    3 акт #    75% - Третья переломная точка\n Ложная победа сменяется катастрофой. герой делает окончательный выбор и должен чем-то пожертвовать или что-то потерять. Самый тёмный момент.    Восстановление\n Герой восстанавливается после катастрофы, переосмысливает свои выборы и утверждается в своей конечной цели.    88% - Начало кульминации\n Герой вступает в финальное противостояние с антагонистической силой.    Кульминация\n Высшее проявление конфликта, приводящее к его разрешению. Стреляют все ружья, даются ответы на все вопросы. Финальная битва, объяснение, разгадка.    98% - Кульминационный момент\n Герой достигает своей цели или окончательно теряет её. Конфликт разрешается.    Развязка\n Передышка после кульминации и картина её последствий.    "},{"id":19,"href":"/obsidian-quickadd-how-to-run-scripts/","title":"Obsidian QuickAdd - как запускать скрипты","section":"Paperless Forest","content":"Плагин для [[./obsidian|Обсидиана]] QuickAdd позволяет автоматически создавать заметки, но ещё его можно использовать в качестве запускалки скриптов.\nJavascript #   Создать файл в формате js и сохранить его в любом месте хранилища. В файле написать код:  module.exports = async (params) =\u0026gt; { /Мой код. В нём можно использовать API Обсидиана и самого плагина./ }  В настройках QuickAdd создать макрос и в настройках макроса выбрать созданный скрипт. Не забыть отметить значок молнии рядом с названием макроса, чтобы активировалась команда. Потом эту команду можно подвязать на хоткей или добавить кнопочку с помощью плагина Commander.  Другие языки и прочие файлы #  QuickAdd не может сам исполнять код на других языках, но может открывать файлы в программе по умолчанию, что позволяет нам запускать, например, shell-скрипты или любые другие файлы, для которых у нас установлена соответствующая программа.\n Нужно добавить файл, который мы хотим запустить, в хранилище. Например, это может быть bash-файл, который коммитит и пушит заметки на гитхаб. Создать js-скрипт и макрос по инструкции выше. В js-файле написать код:  module.exports = async (params) =\u0026gt; { let scriptPath = \u0026#34;\\\\scripts\\\\myFile.sh\u0026#34; /Здесь вместо моего примера надо указать путь к файлу, который мы хотим запустить. Путь указывается относительно хранилища. Обязательно надо эскейпить обратные слэши/ let cmd = this.app.vault.adapter.basePath + scriptPath const { promisify } = require(\u0026#39;util\u0026#39;); const exec = promisify(require(\u0026#39;child_process\u0026#39;).exec); await exec(cmd); } Этот скрипт запускает файлы на Windows. В других системах код может отличаться, в частности, путь будет записываться прямыми слэшами, но может, есть и другие нюансы, не знаю. Поскольку мы не прописываем напрямую путь к хранилищу, а находим его с помощью кода, этот скрипт может работать на разных устройствах.\nЗапрашивать подтверждение перед выполнением скрипта #  Это может быть полезно, если скрипт делает что-то опасное, или если мы используем автоматизированный запуск скрипта, но иногда хотим от него отказаться. Например, у меня настроен скрипт, который делает пул с гитхаба каждый раз при запуске программы, но иногда я закрываю и открываю Обсидиан несколько раз в течение рабочего дня и не вижу смысла каждый раз пулить.\nmodule.exports = async (params) =\u0026gt; { const { quickAddApi: { yesNoPrompt } } = params; const runScript = await yesNoPrompt(\u0026#34;Выполнить скрипт?\u0026#34;); if (runScript) { /Здесь пишем код, который будет выполняться при подтверждении/ } } Вызывать системные команды Обсидиана изнутри скрипта #  Вообще-то QuickAdd может сам вызывать команды через макрос, безо всяких скриптов. Но иногда нам может понадобиться обернуть команду в какой-то код, и для этого нам поможет такой скрипт:\nmodule.exports = async (params) =\u0026gt; { /Какой-то код/ await app.commands.executeCommandById(id) /где id — это id конкретной команды/ /Какой-то код/ } Чтобы узнать id команды, можно открыть консоль и написать код:\nconsole.log(app.commands.commands) Это выведет список всех доступных на данный момент команд, включая команды из установленных плагинов, где указаны их названия и id.\nПример — скрипты для обновления вкладок #  В качестве бонуса — парочка маленьких полезных скриптов, который могут пригодиться.\nСкрипт, чтобы обновить текущую активную вкладку:\nmodule.exports = async (params) =\u0026gt; { await app.workspace.activeLeaf.rebuildView() } Скрипт, чтобы обновить все открытые вкладки:\nmodule.exports = async (params) =\u0026gt; { await app.workspace.rightSplit.children.forEach(pane =\u0026gt; { pane.children[pane.currentTab].rebuildView() }) await app.workspace.leftSplit.children.forEach(pane =\u0026gt; { pane.children[pane.currentTab].rebuildView() }) await app.workspace.rootSplit.children.forEach(pane =\u0026gt; { pane.children[pane.currentTab].rebuildView() }) } Обновление вкладок может быть полезно при использовании некоторых плагинов, например Dataview и Supercharged Links, потому что они не всегда обновляют вид в реальном времени.\n"},{"id":20,"href":"/pocketbook-collection-manager/","title":"Менеджер коллекций для Покетбука","section":"Paperless Forest","content":"У меня есть читалка Покетбук, и в ней можно сортировать книги по полочкам. Но массово это в самой читалке делать неудобно, так что я накодила вот такую прогу: PocketBook Collection Manager.\nЭто ученический проект, который нуждается в доработке, но дело своё делает.\n"}]