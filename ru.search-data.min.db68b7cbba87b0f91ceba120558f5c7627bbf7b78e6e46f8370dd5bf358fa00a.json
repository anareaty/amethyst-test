[{"id":0,"href":"/feed/","title":"Лента","section":"Paperless Forest","content":"\r\nfeed\r\n"},{"id":1,"href":"/tags/","title":"Тэги","section":"Paperless Forest","content":"tags\n"},{"id":2,"href":"/how-to-create-site/","title":"Как создать бесплатный статический сайт из заметок Obsidian","section":"Paperless Forest","content":"Преамбула #  В приложении Obsidiian есть встроенный сервис Publish, который позволяет создать свой сайт и публиковать заметки в интернете в один клик. Но у него есть как плюсы, так и минусы.\nПлюсы:\n минимум настроек, всё работает из коробки; поддерживается весь основной функционал Обсидиана.  Минусы:\n он платный (и довольно дорогой); ограниченные возможности настройки сайта.  К счастью, есть бесплатные альтернативы, которые, вдобавок, дают гораздо больше контроля над внешним видом и функционалом сайта. Минусом этих альтернатив можно считать то, что придётся изрядно повозиться с настройкой.\nЭтот мой сайт сделан совершенно бесплатно (я только заплатила сто рублей за домен, но даже это было необязательно). Он хостится на Github Pages и создан при помощи генератора статических сайтов Hugo. Но главное — новые страницы публикуются напрямую из Обсидиана, одной командой. В этой статье я расскажу, как можно сделать подобный сайт самостоятельно.\nОбщая информация #  Генерация сайта происходит в два этапа. Во-первых, нужно отправить заметку из Обсидиана в репозиторий на гитхабе. Во-вторых, добавленные Markdown-файлы нужно преобразовать в Html-страницы и собрать из них сайт. Для первого этапа нам понадобится установить плагин для Обсидиана Github Publisher. За второй будет отвечать специальный шаблон, который мы разместим в репозитории. Шаблон будет применяться автоматически каждый раз при добавлении нового файла.\nНачать настройку сайта лучше всего с выбора шаблона. Шаблон — это набор правил, по которым кучка маркдаун-файлов преобразуется в сайт. Он определяет внешний вид и функционал сайта: расположение элементов, меню и иконки, стили, скрипты и т. п., а также правила, по которым синтаксис Markdown преобразуется в Html. В интернете можно найти огромное количество шаблонов для статических сайтов, но не все они поддерживают специфический синтаксис Обсидиана, поэтому лучше всего выбирать шаблон, специально заточенный под Обсидиан. Популярным вариантом является Quartz. Ещё можно попробовать Mkdocs или Amethyst. Мой сайт сделан на основе шаблона Amethyst, но его я не рекомендую, потому что он сильно устаревший, и мне пришлось его очень здорово переписать под себя. Может быть, когда-нибудь я напишу и опубликую документацию к собственному шаблону (пока что он сыроват).\nВ целом любые шаблоны устанавливаются и работают примерно одинаково, но могут иметь небольшие отличия в настройках, поэтому придётся читать документацию к конкретному выбранному шаблону. Я опишу установку на примере шаблона Quartz, хотя сама его не использую, но он наиболее актуальный из доступных.\nСоздание и настройка сайта на базе Quartz #  Установка шаблона на Github Pages #  Вот самый простой способ быстро создать сайт на базе Quartz:\n Зарегистрироваться на Github (если ещё нет аккаунта). Открыть репозиторий шаблона и нажать кнопку «Use this template». Создать новый публичный репозиторий. Переименовать ветку v4 в main. Отредактировать файл deploy.yml в папке .github/workflows, удалив строку token: ${{ secrets.GH_PAT }}. Перейти на страницу Settings —\u0026gt; Pages и выбрать Source —\u0026gt; Github Actions. Перейти на страницу Settings —\u0026gt; Environments — удалить все. В папке content создать файл index.md. Он обязательно должен содержать фронтмэттер со свойством title, содержащим заголовок для главной страницы. Снова перейти на страницу Settings —\u0026gt; Pages. Там появится ссылка на ваш новый сайт.  Настройка сайта #  Теперь для настройки сайта необходимо отредактировать файл quartz.config.ts. В нём нужно изменить следующие свойства:\n pageTitle — указать своё название сайта; locale — поменять на \u0026quot;ru-RU\u0026quot;; baseUrl — здесь нужно указать свой адрес сайта (без \u0026quot;https://\u0026quot;); theme — здесь можно заменить шрифты и цвета на какие вам хочется.  Дополнительно можно поменять внешний вид сайта:\n отредактировав файл quartz.layout.ts— можно поменять расположение элементов на сайте; отредактировав scss-файлы в папке quartz/styles.  Больше о настройках можно узнать в документации Quartz\nДля добавления новых страниц на сайт Markdown-файлы должны добавляться в папку content. При этом каждый Markdown-файл должен как минимум содержать свойство title. Далее мы настроим, чтобы эти файлы туда добавлялись автоматически из Обсидиана.\nЛокальная копия сайта #  Редактировать файлы сайта можно прямо на гитхабе (что не очень удобно и медленно, но зато не нужно ничего скачивать и устанавливать). Либо можно скопировать их на свой компьютер с помощью Git и редактировать локально.\nЧтобы запустить локальную копию сайта для отладки:\n Установите Git. Установите Node (после установки требуется перезагрузить компьютер). В своём репозитории скопируйте адрес для клонирования (Code —\u0026gt; HTTPS —\u0026gt; копировать) Откройте терминал и введите команду:  git clone \u0026lt;скопированный адрес\u0026gt; После этого все файлы с гитхаба скопируются в папку с названием репозитория на вашем компьютере, где их можно будет удобно редактировать. Когда всё скопируется, введите команды:\ncd \u0026lt;название скопированной папки\u0026gt; npx quartz build --serve Эта команда запускает сайт на локальном сервере. В браузере откройте адрес http://localhost:8080/. Это локальная версия сайта, где будут сразу отображаться все изменения, которые вы сделаете в скопированных файлах.\nПосле того, как настройка закончена, можно отправить отредактированные файлы обратно на гитхаб с помощью команд:\ngit add --a git commit -m \u0026#34;My cool new changes\u0026#34; git push origin main Собственный домен #  По умолчанию адрес сайта на Github Pages отображается в формате \u0026lt;имя аккаунта\u0026gt;.github.io/\u0026lt;название репозитория\u0026gt;, но если вы хотите адрес покрасивее, то можно купить и настроить свой собственный домен. Как это сделать, я рассказывать не буду, потому что нашла очень доступную и внятную статью об этом.\nНастройка Gihub Publisher #  Теперь, когда сайт готов, нужно добавить возможность публиковать новые страницы напрямую из Обсидиана. Для этого нужно будет настроить в Обсидиане плагин Gihub Publisher.\n Установливаем плагин На гитхабе переходим на страницу Settings — Developer settings — Personal access tokens — Fine-grained tokens — Generate new token. Придумываем название токена, указываем продолжительность действия и репозитории, к которым он применяется (лучше указать только репозиторий сайта). Затем указываем разрешения для репозитория. Их очень много, и они непонятные, поэтому лично я просто выставляю максимальные разрешения на всё. После генерации токен обязательно нужно где-то сохранить, потому что второй раз вам его не покажут. Открываем настройки Github Publisher и указываем следующие данные:  Вкладка Github config:  Имя своего аккаунта на гитхабе. Название репозитория. Токен.   Вкладка File paths:  Default folder — content. Root folder — content.   Вкладка Content:  Internals links — да. Convert internal links pointing to unpublished notes — да. Wikilinks to MDlinks — нет.   Attachment \u0026amp; embeds:  Send linked files — нет. Transfer attachments — да. Остальные настройки указываются по желанию. Дополнительно о возможностях плагина можно почитать в документации.      Публикация заметок #  Теперь можно публиковать заметки. Нужно создать заметку и добавить к ней свойство share: true, а также свойство title для заголовка. Можно добавить и другие свойства (в соответствии с настройками плагина и встроенными свойствами, указанными в документации Quartz), но эти обязательные. После этого в палитре команд вызываем команду Upload single current active note.\nЕсли всё настроено правильно, то появится сообщение, что заметка опубликована. Для проверки можно зайти в репозиторий и убедиться, что заметка добавилась в папку content. Обычно после этого нужно с полминуты подождать прежде чем страница отобразится на сайте.\nЕсли заметка добавилась на гитхаб, но на сайте не появляется, можно открыть в репозитории вкладку Actions и посмотреть, какие процессы там происходят. Если последний процесс отображается с красным крестиком, значит, при генерации сайта произошла ошибка, и там можно прочитать, что именно пошло не так.\nЗаключение #  Надеюсь, это будет кому-нибудь полезно! Я сама не использую Quartz, потому что узнала о нём только после того, как практически написала собственный шаблон на Hugo, но я его тестировала, и он выглядит очень неплохо. Вдобавок, по тому же принципу можно настроить любой другой шаблон, будь то Hugo, Jekyll и так далее. Я перепробовала несколько разных вариантов, и, когда усвоишь общую идею, разница невелика.\nЯ сама не очень-то программист, и мне пришлось местами поломать голову, разбираясь во всех нюансах настройки, несмотря на наличие документации. Поэтому я постаралась расписать весь процесс максимально подробно, но при этом не вдаваясь в лишние дебри, чтобы инструкция была понятна даже людям, не слишком разбирающимся в гитхабе и прочих технологиях.\n"},{"id":3,"href":"/syncthing/","title":"Syncthing","section":"Paperless Forest","content":"Приложение для синхронизации файлов между устройствами (напрямую, без облаков).\nПреимущества Syncthing #   Синхронизация очень быстрая. Файлы не хранятся нигде в облаках и на чужих серверах, а только на моих устройствах. Есть версионирование и отслеживание конфликтов, что позволяет восстанавливать потерянные данные. Синхронизация возможна даже без интернета (например, по локальной сети). Работает на любых устройствах (я даже ухитрилась впихнуть Syncthing на свою читалку Pocketbook). Можно синхронизировать любые папки на устройстве, независимо от их расположения (в том числе даже на флэшке). Бесплатная синхронизация любых объёмов данных без ограничений. Опенсорсный проект.  Недостатки Syncthing #   Очень много не совсем понятных настроек, в которых легко запутаться, особенно не технарю. Иногда бывают конфликты с удалёнными файлами при синхронизации нескольких устройств.  "},{"id":4,"href":"/change-history/","title":"История изменений","section":"Paperless Forest","content":"14 мая 2024 #   NEW [[./how-to-create-site|Как создать бесплатный статический сайт из заметок Obsidian]]  13 мая 2024 #   Добавила коллауты-списки. Удалила лишние страницы.  Теперь на сайте не будет новостных постов. Все обновления сайта будут отображаться на этой странице, а текущие мысли и идеи — публиковаться в мастодоне.    08 мая 2024 #   Добавила виджет для отображения последних записей на Mastodon.  18 марта 2024 #   Создала эту страницу для отслеживания истории изменений на сайте.  29 февраля 2024 #   NEW [[./digital-garden|Цифровой сад]]  23 января 2024 #   Переделала структуру сайта. Теперь все страницы (кроме блог-постов) лежат в корне сайта. Это упрощает ссылки и помогает сохранять их неизменными. Временно сломана иерархия в меню навигации. Починила меню. Теперь папки в меню работают, но больше не связаны с фактической структурой сайта, так что я могу менять их произвольно, не ломая при этом ссылки. Убрала всплывающие окошки для предпросмотра страниц при наведении на ссылку. Они , конечно, прикольные, но на мой взгляд больше мешаются и раздражают. Поправила стили для коллаутов.  21 января 2024 #   NEW [[./Canvas-style-menu-settings|Пресет настроек для плагина Canvas Style Menu]]  18 декабря 2023 #   Пофиксила добавление картинок и сделала стиль блога чуть более минималистичным.  17 декабря 2023 #   NEW [[./sidebar-images|Css для картинок в сайдбаре]]  16 декабря 2023 #   NEW [[./how-to-reuse-dataviewjs-code|Как переиспользовать код с помощью dataviewjs]]  03 октября 2023 #   Сайт получил собственный домен: paperless-forest.ru.  02 октября 2023 #   Добавила на сайт бэклинки. Добавила предпросмотр ссылки при наведении. Доработала стили.  29 сентября 2023 #   Добавила на сайт функциональные тэги. Доработала ленту блога.  19 сентября 2023 #   NEW [[./sync-syncthing-without-internet|Синхронизация через Syncthing без интернета]]  11 сентября 2023 #   Окончательно запустила новый сайт! 🎉  09 сентября 2023 #   NEW [[./about|Обо мне]]  08 сентября 2023 #   NEW [[../Obsidian|Obsidian]] NEW [[./custom-checkboxes|Кастомные чекбоксы в Obsidian]]  07 сентября 2023 #   NEW [[./_index|Главная страница сайта]] NEW [[./three-act-structure|Трёхактная структура]] NEW [[./obsidian-quickadd-how-to-run-scripts|Obsidian QuickAdd - как запускать скрипты]] NEW [[./pocketbook-collection-manager|Менеджер коллекций для Покетбука]]  "},{"id":5,"href":"/digital-garden/","title":"Цифровой сад","section":"Paperless Forest","content":"Цифровой сад (digital garden) — это личный сайт, где можно делиться своими мыслями. Отличием цифрового сада от блога является то, что записи не выстроены в хронологической последовательности, и их можно просматривать в любом порядке при помощи перекрёстных ссылок и тэгов, по принципу Википедии. Записи в цировом саду не обязательно являются законченными, а могут постепенно дополняться и уточняться.\nМой сайт является цифровым садом наполовину: в нём есть лента блога, но она существует отдельно от основных записей, которые не привязаны к хронологии.\nСсылки на интересные цифровые сады:\n  Fork My Brain  Maggie Appleton  Andy Matuschak  "},{"id":6,"href":"/Canvas-style-menu-settings/","title":"Пресет настроек для плагина Canvas Style Menu","section":"Paperless Forest","content":"Недавно появился ещё пока неофициальный плагин для Обсидиана, Canvas Style Menu, который расширяет меню редактирования карточки на холсте. С его помощью можно не только изменять цвет карточек, но и добавлять к ним любые другие стили. Правда, по умолчанию там довольно мало настроек, но можно добавить свои настройки самостоятельно. Я долго ковырялась, но наконец настроила все правила, какие мне хотелось. Если вдруг кому тоже хочется делать в канвасе красивое, но неохота копаться в настройках и css, делюсь своим пресетом:\n Установите плагин через BRAT. Если устанавливали раньше, обновите, там появились новые фишечки. Скачайте этот файл и положите его в папку .obsidian/plugins/canvas-style-menu/packages. Создайте, если её нет. Скачайте и подключите сниппет. В настройках плагина нажмите кнопку Reload packages и выберите пакет CSM Reaty settings Стили вдохновлялись частично Canvas Candy, частично самим плагином, но кое-что я добавила от себя. Весь функционал можно посмотреть на картинке:   "},{"id":7,"href":"/sidebar-images/","title":"Css для картинок в сайдбаре","section":"Paperless Forest","content":"Иногда хочется украсить свой Обсидиан картинками, но чтобы это смотрелось ненавязчиво. Я не очень люблю фоновые картинки и баннеры в заметках, но мне нравится добавлять картинки в боковую панель.\nДля этого нужно сперва добавить файл изображения в хранилище, открыть его, а затем перетащить и закрепить в боковой панели, над или под основными вкладками.\nНо по умолчанию такая картинка смотрится не очень хорошо, потому что получаются лишние отступы, и верхняя панель занимает слишком много места. Вот как это выглядит:\n Чтобы улучшить отображение картинки я написала такой css-сниппет:\n:is(.mod-left-split, .mod-right-split) .workspace-tabs:has(.image-container):not(.mod-active) .workspace-tab-header-container {  display: none; }  :is(.mod-left-split, .mod-right-split) .workspace-tabs:has(.image-container) {  max-height: 150px;; }  :is(.mod-left-split, .mod-right-split) .workspace-tabs:has(.image-container) .workspace-tab-container .view-content {  padding: 0;  overflow: hidden; }  :is(.mod-left-split, .mod-right-split) .workspace-tabs:has(.image-container):not(.mod-active) .workspace-tab-container .view-content .image-container {  padding-top: 5px;  }  :is(.mod-left-split, .mod-right-split) .workspace-tabs:has(.image-container) .workspace-tab-container .view-content .image-container {  width: 100%;  height: 100%; }  :is(.mod-left-split, .mod-right-split) .workspace-tabs:has(.image-container) .workspace-tab-container .view-content img {  width: 100%;  height: 100%;  object-fit: cover; } После подключения сниппета картинка выглядит так:\n Теперь она занимает всю область, без отступов, и выглядит более стильно. Верхняя панель скрыта и будет появляться только при клике на картинку.\n"},{"id":8,"href":"/how-to-reuse-dataviewjs-code/","title":"Как переиспользовать код с помощью dataviewjs","section":"Paperless Forest","content":"Иногда код dataviewjs получается слишком большим, или один и тот же кусок кода нужно использовать несколько раз в разных местах. Поэтому хочется не писать его весь в заметке, а часть кода вынести в отдельный модуль.Теоретически это можно сделать при помощи стандартного метода require, но проблема в том, что он не работает на мобильном.\nРаньше я использовала для этого плагин CustomJS, но теперь выяснила, как можно обойтись стандартным функционалом Dataview.\nДля этого используется функция dv.view().\nСначала создаём файл с расширением .js, например, my_сode.js, и кладём его в любое место в своём хранилище Обсидиана. Для примера положим его в папку scripts. Пишем в нём весь код, который хотим переиспользовать. Например, напишем там следующий код:\ndv.paragraph(\u0026#34;Hello world!\u0026#34;) Затем в заметке в блоке dataviewjs пишем:\nawait dv.view(\u0026#34;scripts/my_code\u0026#34;) При этом весь код, содержащийся в файле my_code.js автоматически исполняется и рендерится. Но что если мы не хотим ничего сразу рендерить, а хотим вернуть какие-то функции или переменные, которые можно использовать позже? Это можно сделать следующим образом.\nВ файле my_code.js пишем:\nthis.myFunc = (x) =\u0026gt; { \tdv.paragraph(x) }  this.myVar = \u0026#34;Hello world!\u0026#34; И в заметке в блоке dataviewjs пишем:\nawait dv.view(\u0026#34;scripts/my_code\u0026#34;)  myFunc(myVar) Подобным же образом можно переиспользовать любые функции или переменные.\nЗамечание: При таком способе все функции и переменные присваиваются глобальному объекту window, что не очень безопасно, потому что можно случайно перезаписать какие-то существующие свойства или методы. Кажется, что безопаснее было бы использовать промежуточный объект.\nНапример, в файле my_code.js пишем:\nconst myFunc = (x) =\u0026gt; { \tdv.paragraph(x) }  const myVar = \u0026#34;Hello world!\u0026#34;  this.myObject = {myFunc, myVar} И в заметке в блоке dataviewjs пишем:\nawait dv.view(\u0026#34;scripts/my_code\u0026#34;)  const {myFunc, myVar} = myObject  myFunc(myVar) У объекта myObject должно быть уникальное имя, не совпадающее ни с одним из свойств объекта window, но с одним объектом это легче проконтролировать, чем со множеством функций и переменных, которые мы можем использовать.\nМожно также использовать класс вместо объекта. В файле my_code.js пишем:\nthis.myClass = class myClass { \tmyFunc() { \tdv.paragraph(\u0026#34;Hello world!\u0026#34;) \t} } И в заметке в блоке dataviewjs пишем:\nawait dv.view(\u0026#34;scripts/my_code\u0026#34;)  const newClass = new myClass  newClass.myFunc() "},{"id":9,"href":"/sync-syncthing-without-internet/","title":"Синхронизация через Syncthing без интернета","section":"Paperless Forest","content":"Я наконец дозрела попробовать Syncthing для синхронизации [[./obsidian|Обсидиана]]. До этого меня останавливало, что там надо, чтобы устройства были в одной сети, а как это организовать вне дома без танцев с бубном, я не знала (всё, что там про какие-то сервера и порты вызывает у меня короткое замыкание в мозгу).\nМоя проблема в том, что мне надо синхронизировать файлы с рабочим компом. На работе у меня нет вайфая, стоит файервол с кучей ограничений, почти все настройки намертво заблокированы, а периодически админы вообще отключают интернет, мол, нефиг расходовать рабочий трафик попусту. Из-за этого большинство методов синхронизации у меня там не работало вообще или работало плохо (мне удалось настроить гит, но он был очень медленный). У меня была мысль раздать вайфай с телефона, но как назло мой провайдер недавно сделал раздачу интернета с телефона платной и жутко дорогой.\nНо недавно я узнала, что, оказывается, Syncthing может синхронизировать вообще без интернета! Достаточно точки доступа. То есть, план действий, такой:\n отключаем мобильный интернет на телефоне (чтобы не расходовать платный трафик); включаем на телефоне точку доступа; подключаем компьютер к этой точке доступа как к вайфаю; запускаем Syncthing.  Профит! Интернета на устройствах нет, но они синхронизируются. Минус способа в том, что приходится отключать интернет на телефоне и держать активной точку доступа, что не всегда удобно, но для быстрой синхронизации в начале и в конце рабочего дня — идеально. И при желании можно синхронизировать устройства хоть в лесу, где связи нет вообще.\n"},{"id":10,"href":"/about/","title":"Обо мне","section":"Paperless Forest","content":"По образованию я филолог, работаю редактором, но кроме того интересуюсь технологиями, изучаю веб-программирование и французский язык, пишу книгу и увлекаюсь миллионом разных вещей.\n"},{"id":11,"href":"/obsidian/","title":"Obsidian","section":"Paperless Forest","content":"Obsidian — приложение для заметок.\n"},{"id":12,"href":"/custom-checkboxes/","title":"Кастомные чекбоксы в Obsidian","section":"Paperless Forest","content":"В [[./obsidian|Обсидиане]] очень удобно использовать свои собственные чекбоксы, например, такие: ![[./images/check.jpg|check.jpg]]\nЕсть темы для Обсидиана, которые уже поддерживают некоторые из подобных чекбоксов, но можно назначить свои собственные при помощи css:\ninput[data-task=\u0026#34;h\u0026#34;]:checked, li[data-task=\u0026#34;h\u0026#34;] \u0026gt; input:checked, li[data-task=\u0026#34;h\u0026#34;] \u0026gt; p \u0026gt; input:checked {  --checkbox-marker-color: transparent;  border: none;  border-radius: 0;  background-image: none;  background-color: currentColor;  -webkit-mask-size: var(--checkbox-icon);  -webkit-mask-position: 50% 50%;   color: var(--color-red);  -webkit-mask-image: url(\u0026#34;data:image/svg+xml,%3Csvg xmlns=\u0026#39;http://www.w3.org/2000/svg\u0026#39; viewBox=\u0026#39;0 0 24 24\u0026#39; width=\u0026#39;18\u0026#39; height=\u0026#39;18\u0026#39; %3E%3Cpath fill=\u0026#39;none\u0026#39; d=\u0026#39;M0 0H24V24H0z\u0026#39;/%3E%3Cpath d=\u0026#39;M12.001 4.529c2.349-2.109 5.979-2.039 8.242.228 2.262 2.268 2.34 5.88.236 8.236l-8.48 8.492-8.478-8.492c-2.104-2.356-2.025-5.974.236-8.236 2.265-2.264 5.888-2.34 8.244-.228z\u0026#39;/%3E%3C/svg%3E\u0026#34;); } Ссылки на svg-иконки, которые подставляются в свойство \u0026ldquo;-webkit-mask-image\u0026rdquo;, можно брать, например, тут: Remix Icon\nЕсли надо сделать чекбокс некликабельным:\n.HyperMD-task-line[data-task=\u0026#34;h\u0026#34;] \u0026gt; .task-list-label, input[data-task=\u0026#34;h\u0026#34;], li[data-task=\u0026#34;h\u0026#34;] \u0026gt; input, li[data-task=\u0026#34;h\u0026#34;] \u0026gt; p \u0026gt; input  {  pointer-events: none; } Шаблон этого сайта поддерживает некоторые кастомные чекбоксы, но не все:\n [n] [n] [r] [r] [\u0026gt;] [\u0026gt;]  Безопаснее использовать буквы, а не символы.\n"},{"id":13,"href":"/three-act-structure/","title":"Трёхактная структура","section":"Paperless Forest","content":" NB Шпаргалка для писателя  1 акт #    1% - Крючок\n Открывающая сцена, которая должна зацепить читателя.    Экспозиция\n Читатель знакомится с миром, героями и конфликтом. Обозначаются цели и ставки.    12% - Побуждающее событие\n Первое активное вмешательство конфликта в Нормальный мир. зов приключений для героя.    Завязка\n Складываются условия для окончательного вступления героя в конфликт. Нарастает напряжение.    25% - Первая переломная точка\n Герой покидает Нормальный Мир, получает цель и вступает в конфликт.    2 акт #    Реакция\n Герой пытается приспособиться к новым обстоятельствам.    37% - Первая точка фокусировки\n Напоминание о конфликте и появление подсказок.    Осознание\n Герой всё больше узнаёт об обстоятельствах и конфликте.    50% - Центральная точка\n Момент истины. Герою раскрывается природа конфликта.    Активное действие\n После получения ключевой информации герой переходит к решительным действиям.    62% - Вторая точка фокусировки\n Предвестие катастрофы и напоминание о ставках.    Обновлённая атака\n Герой действует ещё активнее и достигает ложной победы.    3 акт #    75% - Третья переломная точка\n Ложная победа сменяется катастрофой. герой делает окончательный выбор и должен чем-то пожертвовать или что-то потерять. Самый тёмный момент.    Восстановление\n Герой восстанавливается после катастрофы, переосмысливает свои выборы и утверждается в своей конечной цели.    88% - Начало кульминации\n Герой вступает в финальное противостояние с антагонистической силой.    Кульминация\n Высшее проявление конфликта, приводящее к его разрешению. Стреляют все ружья, даются ответы на все вопросы. Финальная битва, объяснение, разгадка.    98% - Кульминационный момент\n Герой достигает своей цели или окончательно теряет её. Конфликт разрешается.    Развязка\n Передышка после кульминации и картина её последствий.    "},{"id":14,"href":"/obsidian-quickadd-how-to-run-scripts/","title":"Obsidian QuickAdd - как запускать скрипты","section":"Paperless Forest","content":"Плагин для [[./obsidian|Обсидиана]] QuickAdd позволяет автоматически создавать заметки, но ещё его можно использовать в качестве запускалки скриптов.\nJavascript #   Создать файл в формате js и сохранить его в любом месте хранилища. В файле написать код:  module.exports = async (params) =\u0026gt; {   /Мой код. В нём можно использовать API Обсидиана и самого плагина./  }  В настройках QuickAdd создать макрос и в настройках макроса выбрать созданный скрипт. Не забыть отметить значок молнии рядом с названием макроса, чтобы активировалась команда. Потом эту команду можно подвязать на хоткей или добавить кнопочку с помощью плагина Commander.  Другие языки и прочие файлы #  QuickAdd не может сам исполнять код на других языках, но может открывать файлы в программе по умолчанию, что позволяет нам запускать, например, shell-скрипты или любые другие файлы, для которых у нас установлена соответствующая программа.\n Нужно добавить файл, который мы хотим запустить, в хранилище. Например, это может быть bash-файл, который коммитит и пушит заметки на гитхаб. Создать js-скрипт и макрос по инструкции выше. В js-файле написать код:  module.exports = async (params) =\u0026gt; {   let scriptPath = \u0026#34;\\\\scripts\\\\myFile.sh\u0026#34; /Здесь вместо моего примера надо указать путь к файлу, который мы хотим запустить. Путь указывается относительно хранилища. Обязательно надо эскейпить обратные слэши/   let cmd = this.app.vault.adapter.basePath + scriptPath  const { promisify } = require(\u0026#39;util\u0026#39;);  const exec = promisify(require(\u0026#39;child_process\u0026#39;).exec);  await exec(cmd);  } Этот скрипт запускает файлы на Windows. В других системах код может отличаться, в частности, путь будет записываться прямыми слэшами, но может, есть и другие нюансы, не знаю. Поскольку мы не прописываем напрямую путь к хранилищу, а находим его с помощью кода, этот скрипт может работать на разных устройствах.\nЗапрашивать подтверждение перед выполнением скрипта #  Это может быть полезно, если скрипт делает что-то опасное, или если мы используем автоматизированный запуск скрипта, но иногда хотим от него отказаться. Например, у меня настроен скрипт, который делает пул с гитхаба каждый раз при запуске программы, но иногда я закрываю и открываю Обсидиан несколько раз в течение рабочего дня и не вижу смысла каждый раз пулить.\nmodule.exports = async (params) =\u0026gt; {   const { quickAddApi: { yesNoPrompt } } = params;  const runScript = await yesNoPrompt(\u0026#34;Выполнить скрипт?\u0026#34;);   if (runScript) {   /Здесь пишем код, который будет выполняться при подтверждении/  } } Вызывать системные команды Обсидиана изнутри скрипта #  Вообще-то QuickAdd может сам вызывать команды через макрос, безо всяких скриптов. Но иногда нам может понадобиться обернуть команду в какой-то код, и для этого нам поможет такой скрипт:\nmodule.exports = async (params) =\u0026gt; {   /Какой-то код/   await app.commands.executeCommandById(id) /где id — это id конкретной команды/   /Какой-то код/  } Чтобы узнать id команды, можно открыть консоль и написать код:\nconsole.log(app.commands.commands) Это выведет список всех доступных на данный момент команд, включая команды из установленных плагинов, где указаны их названия и id.\nПример — скрипты для обновления вкладок #  В качестве бонуса — парочка маленьких полезных скриптов, который могут пригодиться.\nСкрипт, чтобы обновить текущую активную вкладку:\nmodule.exports = async (params) =\u0026gt; {   await app.workspace.activeLeaf.rebuildView() } Скрипт, чтобы обновить все открытые вкладки:\nmodule.exports = async (params) =\u0026gt; {   await app.workspace.rightSplit.children.forEach(pane =\u0026gt; {   pane.children[pane.currentTab].rebuildView()  })   await app.workspace.leftSplit.children.forEach(pane =\u0026gt; {   pane.children[pane.currentTab].rebuildView()  })   await app.workspace.rootSplit.children.forEach(pane =\u0026gt; {   pane.children[pane.currentTab].rebuildView()  }) } Обновление вкладок может быть полезно при использовании некоторых плагинов, например Dataview и Supercharged Links, потому что они не всегда обновляют вид в реальном времени.\n"},{"id":15,"href":"/pocketbook-collection-manager/","title":"Менеджер коллекций для Покетбука","section":"Paperless Forest","content":"У меня есть читалка Покетбук, и в ней можно сортировать книги по полочкам. Но массово это в самой читалке делать неудобно, так что я накодила вот такую прогу: PocketBook Collection Manager.\nЭто ученический проект, который нуждается в доработке, но дело своё делает.\n"}]